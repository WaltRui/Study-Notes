# 基础知识点

------

## 关键字

### 1. abstract和interface
#### 介绍
interface强调特定功能的实现，而abstract class强调所属关系。

#### 应用场景
##### interface的应用场合
> * 类与类之前需要特定的接口进行协调，而不在乎其如何实现。
> * 作为能够实现特定功能的标识存在，也可以是什么接口方法都没有的纯粹标识。
> * 需要将一组类视为单一的类，而调用者只通过接口来与这组类发生联系。
> * 需要实现特定的多项功能，而这些功能之间可能完全没有任何联系。

##### abstract class的应用场合
在既需要统一的接口，又需要实例变量或缺省的方法的情况下。Abp中，部分以Base后缀的需要具体实现的类，如AbpController，AbpRepositoryBase均为抽象类。
> * 定义了一组接口，但又不想强迫每个实现类都必须实现所有的接口。可以用abstract class定义一组方法体，甚至可以是空方法体，然后由子类选择自己所感兴趣的方法来覆盖。
> * 某些场合下，只靠纯粹的接口不能满足类与类之间的协调，还必需类中表示状态的变量来区别不同的关系。abstract的中介作用可以很好地满足这一点。
> * 规范了一组相互协调的方法，其中一些方法是共同的，与状态无关的，可以共享的，无需子类分别实现；而另一些方法却需要各个子类根据自己特定的状态来实现特定的功能

#### 相关参考
http://blog.csdn.net/xcbeyond/article/details/7667733

https://msdn.microsoft.com/zh-cn/library/sf985hc5

《C# 高级编程（第九版）》 4.3.2章节 和4.5章节

### 2.  virtual和new
#### 介绍
使用new 关键字表示隐藏基类同名方法。
~~~ C#
class Base{
    public virtual void ShowMessage()
    {
        Console.WriteLine ("Base.show");
    }
}

class Class1:Base{
    public new void ShowMessage()
    {
        Console.WriteLine ("class1.show");
    }
}
~~~
使用override 关键字来表示覆盖父类的同名方法。 覆盖和重写不同的是覆盖可以再调用父类的同名方法， 加一个base关键字就可以了。前提是基类方法需要使用virtual关键字表示这个方法会被覆盖。
~~~ C#
class Class2:Base{
    public override void ShowMessage()
    {
        Console.WriteLine ("class2.show");
        //base.SHowMessage();  // Base.show
    }
}
~~~
两者区别在于调用时：
~~~ C#
Base c = new Class1();
c.ShowMessage();//输出： Base.show
c = new Class2();
c.ShowMessage();//输出： class2.show
~~~
Base为声明类，而Class1和Class2为实例类，在执行c.ShowMessage();时，会
> 1. 先查看声明类（Base）中此方法是否为虚方法。
> 2. 如果不是虚方法，直接执行声明类（Base）中此方法。
> 3. 如果是虚方法，查找实例类（Class1或Class2）中是否有override此同名方法，如果有，执行实例类中同名方法。
> 4. 如果没有，执行声明类同名方法。

#### 应用场景
用于需要覆盖的方法，ABP中以Base后缀的类中方法基本都是virtual。

### 3. internal
只能在包含它的程序集中访问该项。在abp框架源码中经常使用，实际使用abp做开发时使用不多。
如果需要在其他程序集使用该程序集中internal的方法或类（如测试工程），可以在被引用项目的AssemblyInfo.cs文件添加InternalsVisibleTo属性。

### 4. Assembly
程序集，定义在System.Reflection命名空间下。用来加载和执行程序集。
#### Abp中使用
在Abp中,多用于模块加载，常用方法：Load、GetExecutingAssembly。
~~~ C#
public override void Initialize()
{
    IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly());
}
~~~
#### 相关参考
https://msdn.microsoft.com/zh-cn/library/system.reflection.assembly(v=vs.110).aspx?cs-save-lang=1&cs-lang=csharp#code-snippet-1

《C# 高级编程（第九版）》 15.3.3章节
### 5. C#和.Net Framework 关系
C#是一门开发语言，是由C及C++演变而来的，Net FrameWork类似于Java 的JVM(虚拟机)，其核心是运行库的执行环境。C#、VB等编写的代码必须在.Net Framework上运行。
### 6. 装箱和拆箱（待完善，值类型、引用类型。）
值类型存储在栈上，引用类型存储在堆上。从值类型转换为引用类型称为装箱，从引用类型转换为值类型称为拆箱。拆箱时，需要使用类型强制转换。
C#所有值类型隐式派生自System.ValueType。数组和string均为引用类型。
~~~~ C#
var list = new ArrayList();
list.Add(10);//装箱，将值类型转换为引用类型。
int i=(int) list[0];//拆箱，将引用类型转换为值类型。使用强制类型转换。
~~~~
####应用场景
> * 调用参数为Object的方法时。
> * 非泛型的容器，为了保证通用，而将元素类型定义为Object。
####性能
装箱和拆箱使用简单，但是对性能损耗较大，尤其是在遍历许多项时。
所以应尽量避免使用装箱和拆箱，可以使用重载和泛型来避免不必要的装箱和拆箱操作。

### 7. 泛型（待完善，类型参数尚未搞清楚）
泛型可用于类、接口、方法和委托。使用了泛型可以保证其类型安全以及可以避免集合添加元素、取出元素时候的装箱、拆箱操作
~~~~ C#
class MyHelper
{
    public static void AddAndPrint(int i, int j)
    {
        Console.WriteLine(string.Format("The value is {0}", i.ToString() + "@" + j.ToString()));
    }
    public static void AddAndPrint(float i, float j)
    {
        Console.WriteLine(string.Format("The value is {0}", i.ToString() + "@" + j.ToString()));
    }
    public static void AddAndPrint(double i, double j)
    {
        Console.WriteLine(string.Format("The value is {0}", i.ToString() + "@" + j.ToString()));
    }
}

static void Main(string[] args)
{
    MyHelper.AddAndPrint(100, 120);
    MyHelper.AddAndPrint(100.123F, 120F);
    MyHelper.AddAndPrint(100.456D, 120.666D);
    Console.ReadKey();
}
~~~~
三个AddAndPrint函数除了参数类型以外，函数体内部实现完全一样，使用泛型实现如下：
~~~~ C#
public abstract class AbpRepositoryBase<TEntity, TPrimaryKey>
{
    public static void AddAndPrint(T t1, T t2)
    {
        Console.WriteLine(string.Format("The value is {0}", t1.ToString() + "@" + t2.ToString()));
    }
}
~~~~

Abp中泛型使用很多，以AbpRepositoryBase为例，如下：
~~~~ C#
    public abstract class AbpRepositoryBase<TEntity, TPrimaryKey> : IRepository<TEntity, TPrimaryKey>
        where TEntity : class, IEntity<TPrimaryKey>
    {
        ....
        public abstract IQueryable<TEntity> GetAll();

        public virtual List<TEntity> GetAllList()
        {
            return GetAll().ToList();
        }
        public virtual TEntity Single(Expression<Func<TEntity, bool>> predicate)
        {
            return GetAll().Single(predicate);
        }
        ...
    }
~~~~
where 约束，此类限定TEntity 必须是引用类型，且继承自IEntity<TPrimaryKey>。
作为约束使用的类型必须是接口，非密封类（使用sealed 修饰符 ）和类型参数。其中常用的几种约束方式：
> * struct：类型参数必须是值类型。可以指定除 Nullable 以外的任何值类型。
> * class：类型参数必须是引用类型，适用于任何类、接口、委托或数组类型。
> * new()：类型参数必须具有无参数的公共构造函数。当与其他约束一起使用时，new() 约束必须最后指定。
> * <基类名称>：类型参数必须是指定的基类或派生自指定的基类。
> * <接口名称>：类型参数必须是指定的接口或实现指定的接口。可以指定多个接口约束。约束接口也可以是泛型的。
> * T2：形如：where T1：T2  指定类型T1派生自泛型类型T2。


#### 泛型优势
> * 类型安全
> * 无需装箱和折箱
> * 无需类型转换
> * 代码复用性高

#### 参考
https://msdn.microsoft.com/zh-cn/library/bb384067.aspx

### 8. IQueryable, IEnumerable, IList (待完善，带测试，)
三个集合接口，常用在EF查询中。
> * IQueryable和IEnumerable都是延时执行的，而IList是即时执行。
> * IQueryable和IEnumerable在每次执行时都必须连接数据库读取，而IList读取一次后，以后各次都不需连接数据库。

#### 参考
http://blog.csdn.net/codefighting/article/details/20324205

### 9. Lambda表达式
lambda表达式在很多地方都有使用，如Linq查询，事件、委托。匿名函数等等。

### 10. LINQ
语言集成查询（Language Integrated Query ，Linq ）在C#编程语言中集成了查询语法，可以用相同的语法访问不同的数据库。
~~~~ C#
//
var users = from u in db.user
                     where u.Id > 10
                     orderby u.Id descending  //倒序
                     select u;

// var users = db.user.OrderByDescending(p => p.Id).Where(p => p.Id > 10).ToList();
~~~~

####参考
http://www.cnblogs.com/knowledgesea/p/3897665.html  （十种LINQ的常用查询方法）

《C#高级编程（第九版）》 第11章 （详细讲解）

### 11. 委托
当需要把方法传递给其他方法时，就需要用到委托。
####使用方法
1. 定义：
~~~~ C#
delegate void MyDelegate(string arg1,int arg2);
~~~~
2. 创建实例：
~~~~ C#
MyDelegate delegate1 = new MyDelegate(Method1);//此方式创建委托并绑定一个方法

MyDelegate delegate2;//创建委托
delegate2 = Method1;//绑定方法，只要返回类型和参数类型一致，可以自动转换为委托
delegate2 += Method2;//添加绑定方法，一个委托可以绑定多个方法，执行时依次执行。

public static void Method1(string arg1,int arg2)
{
    Console.WriteLine("Method1:"+arg1+"("+arg2+")");
}
public static void Method2(string arg1,int arg2)
{
    //Method2
}
~~~~
3. 使用
可以直接执行委托：
~~~~ C#
delegate1("abc",10);
~~~~
也可以作为参数传递给其他方法（该方法接收类型为该委托的参数）：
~~~~ C#
Method13(delegate2,"abc",10);//执行方法Method2,将委托实例作为参数传递

private void Method3(MyDelegate delegate,string arg1,int arg2)
{
    //...
    delegate(arg1,arg2);
}
~~~~
委托可以同时绑定多个实例。
####使用场景
方法执行的操作并不是针对数据进行，而是要对另一个方法进行操作，而且，在编译阶段无法得知第二个方法时什么，只有在运行时才能
得知，这是需要把第二个方法作为参数传递个第一个方法，这就使用到了委托。如下几个常用委托的场景：
> * 启动线程和任务
> * 通用库类
> * 事件

####参考
http://www.tracefact.net/CSharp-Programming/Delegates-and-Events-in-CSharp.aspx

### 12. 事件
事件基于委托，为委托提供了一种发布/订阅机制。是类在发生其关注的事情时用来提供通知的一种方式。
####使用方法
1. 声明一个委托：
~~~~ C#
public delegate void PublishEventHander();
~~~~
2. 在委托的机制下我们建立以个出版事件：
~~~~ C#
 public event PublishEventHander OnPublish;
~~~~
3. 触发：
事件必须要在方法里去触发：
~~~~ C#
 public void issue()
{
    //如果有人注册了这个事件，也就是这个事件不是空
    if (OnPublish != null)
    {
        Console.WriteLine("触发事件");
        OnPublish();
    }
}
~~~~
4. 订阅：

~~~~ C#
Publisher publisher = new Publisher();

//为事件注册订阅者
publisher.OnPublish += new Publisher.PublishEventHander(Receive);
//另一种事件注册方式
//publisher.OnPublish += Receive;
//发布者在这里触发事件
publisher.issue();
~~~~
订阅者的相关事件
~~~~
public static void Receive()
{
    Console.WriteLine("我是XXX,我已经接到通知");
}
~~~~
####参考
http://www.cnblogs.com/wudiwushen/archive/2010/04/20/1703763.html（通俗易懂）
### 13. 异步编程
使用异步编程，方法调用是在后台运行（通常在线程或任务的协助下），并不会阻塞调用线程。
#### 3种模式
> * 异步模式
> * 基于事件的异步模式
> * 基于任务的异步模式

主要介绍第三种基于任务的异步模式。
一般情况下，该模式定义一个带有“Async” 后缀的方法，并且返回一个Task类型。
方法声明的返回值类型为Task<T> ，但并不需要声明一个Task<T>类型的变量作为返回结果。只需要声明一个T类型的变量，并使用await关键字即可。

如，Abp中AbpRepositoryBase类中的GetAsync方法：
~~~~ C#
public virtual async Task<TEntity> GetAsync(TPrimaryKey id)
{
    var entity = await FirstOrDefaultAsync(id);
    if (entity == null)
    {
        throw new AbpException("There is no such an entity with given primary key. Entity type: " + typeof(TEntity).FullName + ", primary key: " + id);
    }
    return entity;
}
~~~~
#### async 和await
使用 async 修饰符可将方法、lambda 表达式或匿名方法指定为异步。
如果 async 关键字修饰的方法不包含 await 表达式或语句，则该方法将同步执行。

####使用
Abp中AbpRepositoryBase类

####参考
https://msdn.microsoft.com/zh-cn/library/hh191443.aspx
https://msdn.microsoft.com/zh-cn/library/hh156513.aspx
《C#高级编程（第9版）》 第13章 异步编程

### 14. HttpApplication
在HttpApplication中，利用.Net中的事件机制，通过在处理过程中依次发出的多个事件，将这个处理过程分解为多个步骤，这个处理机制通常我们称为处理管道。
HttpApplication处理管道示意图：
![aaa](http://images.cnitblog.com/blog/347600/201401/211102040003.jpg)

http://www.cnblogs.com/kissdodog/p/3527922.html

### 15. VS使用，项目结构
> * 使用第三方类库，通过Nuget或直接应用项目或dll文件。在需要使用的类添加Using 引用，就可以正常使用。


创建项目的同时会创建一个解决方案，之后可以在此解决方案上添加新项目。

####项目类型
如图，新建项目中列出了使用C#开发，常用的一些项目类型，而如果是开发Web项目，常用的项目类型为图中圈出的四种：
> * ASP.NET Web Application(.NET Framework)
> * 类库
> * ASP.NET Core Web Application(.NET Core)
> * ASP.NET Core Web Application(.NET Framework)
> * Class Library(.NET Core)


![vs_new_project](imgs/vs_new_project.png)

后三个后面再介绍，先看前两个项目的项目结构
#### 项目结构
类库项目和Web App项目都会有Properties、引用 以及项目自身的文件，部分需要配置信息的项目会有app.config或者web.config文件。Web 应用程序会有Global.asax和StartUp.cs文件作为启动入口和相关配置；使用NuGet的话，会有packages.config文件来管理NuGet程序包。

Properties下有AssemblyInfo.cs文件。此文件下包含了该程序集的相关信息，如果此项目下部分内部类需要被其他项目使用，可在此文件设置InternalsVisibleTo 属性。
Abp中Abp项目下的AssemblyInfo.cs文件配置如下：
~~~~ C#
[assembly: AssemblyTitle("ASP.NET Boilerplate")]
[assembly: AssemblyDescription("ASP.NET Boilerplate")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Volosoft")]
[assembly: AssemblyProduct("Abp")]
[assembly: AssemblyCopyright("Copyright © 2016")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

[assembly: InternalsVisibleTo("Abp.Application")]
[assembly: InternalsVisibleTo("Abp.EntityFramework")]
[assembly: InternalsVisibleTo("Abp.EntityFrameworkCore")]
[assembly: InternalsVisibleTo("Abp.NHibernate")]
[assembly: InternalsVisibleTo("Abp.Web.Common")]
[assembly: InternalsVisibleTo("Abp.AspNetCore")]
[assembly: InternalsVisibleTo("Abp.Web")]
[assembly: InternalsVisibleTo("Abp.Web.Api")]
[assembly: InternalsVisibleTo("Abp.Web.Mvc")]
[assembly: InternalsVisibleTo("Abp.Web.Resources")]

[assembly: InternalsVisibleTo("Abp.Tests")]
[assembly: InternalsVisibleTo("Abp.EntityFramework.Tests")]
[assembly: InternalsVisibleTo("Abp.RedisCache.Tests")]
[assembly: InternalsVisibleTo("Abp.Web.Tests")]
[assembly: InternalsVisibleTo("Abp.Web.Api.Tests")]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("7b50eb47-4993-4a14-b65c-b61714a607b9")]
~~~~
其中设置InternalsVisibleTo属性的部分，即表示该程序集内部类（internal修饰）对其指定的项目开放使用。

而 ASP.NET Web Application 项目除了以上内容外，还包括了如下图所示的内容，包括一些静态文件、css、js以及Controller、Model和View模板等内容。App_Start还有一些路由、Bundle的配置信息。

####参考
https://docs.asp.net/en/latest/intro.html
http://www.cnblogs.com/Leo_wl/p/5507534.html


### 16. EF
#### DbContext、DbSet
定义了从实体对象到数据库的映射。官方解释：DbContext 实例表示工作单元和存储库模式的组合，可用来查询数据库并将更改组合在一起，这些更改稍后将作为一个单元写回存储区中。
我们只需知道是用来通过实体对象查询和操作数据库就足够。
在使用Abp框架时，会创建一个类（一般会以DbContext为后缀）直接或间接继承自AbpDbContext。
而在Abp框架中，AbpDbContext继承自DbContext,而且对AbpDbContext又进行了多次封装，最终在使用Abp框架时，只需要了解类EfRepositoryBase中常用的方法即可正常使用EF。

DbSet 表示上下文中给定类型的所有实体的集合或可从数据库中查询的给定类型的所有实体的集合。DbContext对哪些实体对象和数据库进行映射，需要通过DbSet指定。

在实际项目中会有一个类直接或间接继承自DbContext，每个项目中定义的实体，都需要在这个类中显示的声明。如下：
~~~~ C#
public class MyAbpProjectDbContext : AbpZeroDbContext<Tenant, Role, User>
{
    //TODO: Define an IDbSet for your Entities...
    public virtual IDbSet<Order> Orders { set; get; }

    /* NOTE:
     *   Setting "Default" to base class helps us when working migration commands on Package Manager Console.
     *   But it may cause problems when working Migrate.exe of EF. If you will apply migrations on command line, do not
     *   pass connection string name to base classes. ABP works either way.
     */
    public MyAbpProjectDbContext()
        : base("Default")
    {

    }
    ...
}
~~~~
#### 使用
基本的查询
~~~~ C#
using (var context = new BloggingContext())
{
    var blogs = context.Blogs.ToList();
    var blog = context.Blogs.Single(b => b.BlogId == 1);
    var blogs2 = context.Blogs
            .Where(b => b.Url.Contains("dotnet"))
            .ToList();//Tolist 为立即加载，如果不使用TOlist将会延迟加载。
}
~~~~

增、删、改。修改数据库的操作，最后需要调用SaveChanges()方法来执行修改。
~~~~ C#
//新增记录
using (var db = new BloggingContext())
{
    var blog = new Blog { Url = "http://sample.com" };
    db.Blogs.Add(blog);
    db.SaveChanges();
}
//修改记录
using (var db = new BloggingContext())
{
    var blog = db.Blogs.First();
    blog.Url = "http://sample.com/blog";
    db.SaveChanges();
}
//删除记录
using (var db = new BloggingContext())
{
    var blog = db.Blogs.First();
    db.Blogs.Remove(blog);
    db.SaveChanges();
}
~~~~

EfRepositoryBase类中方法如下：
![EfRepositoryBase](imgs/EfRepositoryBase.png)
其他相关操作可参加官方文档。
##### 参考
https://docs.efproject.net/en/latest/  官方文档
https://code.msdn.microsoft.com/101-LINQ-Samples-3fb9811b/viewsamplepack  Linq
### 17. NuGet
类似于NodeJs中的npm。
#### NuGet程序包管理
可以在项目或者解决方案上右键选择管理NuGet程序包即可进入可视化管理界面。
在菜单栏--工具--NuGet包管理器---程序包管理控制台，可进入包管理控制台，也可在此通过命令行的形式管理程序包，或其他一些操作（Migration经常用到）。
####程序包源配置
在菜单栏--工具--NuGet包管理器---程序包管理设置。选择程序包源选项，可添加程序包源。 公司的程序包源地址为：


###ASP.NET Core 1.0
由ASP.NET 5 改名而来，同时名称变动的有：
> * ASP.NET 5 –> ASP.NET Core 1.0
> * .NET  5 –> .NET Core 1.0
> * Entity Framework 7 –> Entity Framework Core 1.0

这里先只对ASP.NET Core 1.0 做简单介绍。
ASP.NET Core是对ASP.NET的重新设计，其主要特色是跨平台。
ASP.NET Core开发的应用程序可以在.NET Core或者.NET Framework上运行。
再来看之前的项目类型。
![vs_new_project](imgs/vs_new_project.png)
其中ASP.NET Core Web Application(.NET Core) 、ASP.NET Core Web Application(.NET Framework)为ASP.NET Core 应用程序在两个不同平台的支持。
和其他两个传统项目主要区别在于完全以NuGet作为依赖引用方式，主要体现在项目中新增了project.json文件，该文件用来管理NuGet引用，包括基础的运行库都可以通过Nuget指定。
ASP.NET Core 优势：
> * 统一了WebUI和Web APIs的创建流程。
> * 整合了现代客户端框架和开发工作流程。
> * 云就绪基础环境的配置系统。
> * 可以将程序寄宿在IIS或自托管服务上。（原文：Ability to host on IIS or self-host in your own process）
> * 全面支持NuGet。(Ships entirely as NuGet packages)
> * 简化了现代Web开发。
> * 可以构建和运行在Windows，Mac和Linux的跨平台的ASP.NET应用。
> * 开源和社区化。


####项目结构
ASP.NET Core 项目或  基于.NET Core 的项目其项目结构略有变化。
> * 使用project.json 来配置项目，包括项目版本，运行平台（.NET Framework 或 .NET Core ）和NuGet程序包管理（弃用了project.json）。
> * Web应用程序更为简洁。
> * web应用程序启动入口变为Program的控制台程序。
> * bundle信息改由 bundleconfig.json管理。

![asp_net_core_web_app.png](imgs/asp_net_core_web_app.png)
![asp_net_core_web_api.png](imgs/asp_net_core_web_api.png)
![asp_net_core_web_api.png](imgs/asp_net_core_web_api.png)



### 附录
####统一了WebUI和Web APIs的创建流程。
![asp_net_core_web_app.png](imgs/asp_net_core_web_app.png)
![asp_net_core_web_api.png](imgs/asp_net_core_web_api.png)
上面两张图分别是
ASP.NET Core Web App和ASP.NET Core Web API的项目结构图，可以发现，除了一些css、js之类的Content和View模板之外，其他完全一样。
而传统的ASP.NET Application 中实现WebAPI需要专门配置API路由信息和其他相关配置。
