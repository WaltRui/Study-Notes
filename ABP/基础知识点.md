# 基础知识点

------

## 关键字

### 1. abstract和interface
#### 介绍
interface强调特定功能的实现，而abstract class强调所属关系。

#### 应用场景
##### interface的应用场合
> * 类与类之前需要特定的接口进行协调，而不在乎其如何实现。
> * 作为能够实现特定功能的标识存在，也可以是什么接口方法都没有的纯粹标识。
> * 需要将一组类视为单一的类，而调用者只通过接口来与这组类发生联系。
> * 需要实现特定的多项功能，而这些功能之间可能完全没有任何联系。

##### abstract class的应用场合
在既需要统一的接口，又需要实例变量或缺省的方法的情况下。Abp中，部分以Base后缀的需要具体实现的类，如AbpController，AbpRepositoryBase均为抽象类。
> * 定义了一组接口，但又不想强迫每个实现类都必须实现所有的接口。可以用abstract class定义一组方法体，甚至可以是空方法体，然后由子类选择自己所感兴趣的方法来覆盖。
> * 某些场合下，只靠纯粹的接口不能满足类与类之间的协调，还必需类中表示状态的变量来区别不同的关系。abstract的中介作用可以很好地满足这一点。
> * 规范了一组相互协调的方法，其中一些方法是共同的，与状态无关的，可以共享的，无需子类分别实现；而另一些方法却需要各个子类根据自己特定的状态来实现特定的功能

#### 相关参考
http://blog.csdn.net/xcbeyond/article/details/7667733

https://msdn.microsoft.com/zh-cn/library/sf985hc5

《C# 高级编程（第九版）》 4.3.2章节 和4.5章节

### 2.  virtual和new
#### 介绍
使用new 关键字表示隐藏基类同名方法。
~~~ C#
class Base{
    public virtual void ShowMessage()
    {
        Console.WriteLine ("Base.show");
    }
}

class Class1:Base{
    public new void ShowMessage()
    {
        Console.WriteLine ("class1.show");
    }
}
~~~
使用override 关键字来表示覆盖父类的同名方法。 覆盖和重写不同的是覆盖可以再调用父类的同名方法， 加一个base关键字就可以了。前提是基类方法需要使用virtual关键字表示这个方法会被覆盖。
~~~ C#
class Class2:Base{
    public override void ShowMessage()
    {
        Console.WriteLine ("class2.show");
        //base.SHowMessage();  // Base.show
    }
}
~~~
两者区别在于调用时：
~~~ C#
Base c = new Class1();
c.ShowMessage();//输出： Base.show
c = new Class2();
c.ShowMessage();//输出： class2.show
~~~
Base为声明类，而Class1和Class2为实例类，在执行c.ShowMessage();时，会
> 1. 先查看声明类（Base）中此方法是否为虚方法。
> 2. 如果不是虚方法，直接执行声明类（Base）中此方法。
> 3. 如果是虚方法，查找实例类（Class1或Class2）中是否有override此同名方法，如果有，执行实例类中同名方法。
> 4. 如果没有，执行声明类同名方法。

#### 应用场景
用于需要覆盖的方法，ABP中以Base后缀的类中方法基本都是virtual。

### 3. internal
只能在包含它的程序集中访问该项。在abp框架源码中经常使用，实际使用abp做开发时使用不多。
如果需要在其他程序集使用该程序集中internal的方法或类（如测试工程），可以在被引用项目的AssemblyInfo.cs文件添加InternalsVisibleTo属性。

### 4. Assembly
程序集，定义在System.Reflection命名空间下。用来加载和执行程序集。
#### Abp中使用
在Abp中,多用于模块加载，常用方法：Load、GetExecutingAssembly。
~~~ C#
public override void Initialize()
{
    IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly());
}
~~~
#### 相关参考
https://msdn.microsoft.com/zh-cn/library/system.reflection.assembly(v=vs.110).aspx?cs-save-lang=1&cs-lang=csharp#code-snippet-1

《C# 高级编程（第九版）》 15.3.3章节
### 5. C#和.Net Framework 关系
C#是一门开发语言，是由C及C++演变而来的，Net FrameWork类似于Java 的JVM(虚拟机)，其核心是运行库的执行环境。C#、VB等编写的代码必须在.Net Framework上运行。
### 6. 装箱和拆箱（待完善，值类型、引用类型。）
值类型存储在栈上，引用类型存储在堆上。从值类型转换为引用类型称为装箱，从引用类型转换为值类型称为拆箱。拆箱时，需要使用类型强制转换。
C#所有值类型隐式派生自System.ValueType。数组和string均为引用类型。
~~~~ C#
var list = new ArrayList();
list.Add(10);//装箱，将值类型转换为引用类型。
int i=(int) list[0];//拆箱，将引用类型转换为值类型。使用强制类型转换。
~~~~
####应用场景
> * 调用参数为Object的方法时。
> * 非泛型的容器，为了保证通用，而将元素类型定义为Object。
####性能
装箱和拆箱使用简单，但是对性能损耗较大，尤其是在遍历许多项时。
所以应尽量避免使用装箱和拆箱，可以使用重载和泛型来避免不必要的装箱和拆箱操作。

### 7. 泛型（待完善，类型参数尚未搞清楚）
泛型可用于类、接口、方法和委托。使用了泛型可以保证其类型安全以及可以避免集合添加元素、取出元素时候的装箱、拆箱操作
~~~~ C#
class MyHelper
{
    public static void AddAndPrint(int i, int j)
    {
        Console.WriteLine(string.Format("The value is {0}", i.ToString() + "@" + j.ToString()));
    }
    public static void AddAndPrint(float i, float j)
    {
        Console.WriteLine(string.Format("The value is {0}", i.ToString() + "@" + j.ToString()));
    }
    public static void AddAndPrint(double i, double j)
    {
        Console.WriteLine(string.Format("The value is {0}", i.ToString() + "@" + j.ToString()));
    }
}

static void Main(string[] args)
{
    MyHelper.AddAndPrint(100, 120);
    MyHelper.AddAndPrint(100.123F, 120F);
    MyHelper.AddAndPrint(100.456D, 120.666D);
    Console.ReadKey();
}
~~~~
三个AddAndPrint函数除了参数类型以外，函数体内部实现完全一样，使用泛型实现如下：
~~~~ C#
public abstract class AbpRepositoryBase<TEntity, TPrimaryKey>
{
    public static void AddAndPrint(T t1, T t2)
    {
        Console.WriteLine(string.Format("The value is {0}", t1.ToString() + "@" + t2.ToString()));
    }
}
~~~~

Abp中泛型使用很多，以AbpRepositoryBase为例，如下：
~~~~ C#
    public abstract class AbpRepositoryBase<TEntity, TPrimaryKey> : IRepository<TEntity, TPrimaryKey>
        where TEntity : class, IEntity<TPrimaryKey>
    {
        ....
        public abstract IQueryable<TEntity> GetAll();

        public virtual List<TEntity> GetAllList()
        {
            return GetAll().ToList();
        }
        public virtual TEntity Single(Expression<Func<TEntity, bool>> predicate)
        {
            return GetAll().Single(predicate);
        }
        ...
    }
~~~~
where 约束，此类限定TEntity 必须是引用类型，且继承自IEntity<TPrimaryKey>。
作为约束使用的类型必须是接口，非密封类（使用sealed 修饰符 ）和类型参数。其中常用的几种约束方式：
> * struct：类型参数必须是值类型。可以指定除 Nullable 以外的任何值类型。
> * class：类型参数必须是引用类型，适用于任何类、接口、委托或数组类型。
> * new()：类型参数必须具有无参数的公共构造函数。当与其他约束一起使用时，new() 约束必须最后指定。
> * <基类名称>：类型参数必须是指定的基类或派生自指定的基类。
> * <接口名称>：类型参数必须是指定的接口或实现指定的接口。可以指定多个接口约束。约束接口也可以是泛型的。
> * T2：形如：where T1：T2  指定类型T1派生自泛型类型T2。


#### 泛型优势
> * 类型安全
> * 无需装箱和折箱
> * 无需类型转换
> * 代码复用性高

#### 参考
https://msdn.microsoft.com/zh-cn/library/bb384067.aspx

### 8. IQueryable, IEnumerable, IList (待完善，带测试，)
三个集合接口，常用在EF查询中。
> * IQueryable和IEnumerable都是延时执行的，而IList是即时执行。
> * IQueryable和IEnumerable在每次执行时都必须连接数据库读取，而IList读取一次后，以后各次都不需连接数据库。

#### 参考
http://blog.csdn.net/codefighting/article/details/20324205

### 9. Lambda表达式
lambda表达式在很多地方都有使用，如Linq查询，事件、委托。匿名函数等等。

### 10. LINQ
语言集成查询（Language Integrated Query ，Linq ）在C#编程语言中集成了查询语法，可以用相同的语法访问不同的数据库。
~~~~ C#
//
var users = from u in db.user
                     where u.Id > 10
                     orderby u.Id descending  //倒序
                     select u;

// var users = db.user.OrderByDescending(p => p.Id).Where(p => p.Id > 10).ToList();
~~~~

####参考
http://www.cnblogs.com/knowledgesea/p/3897665.html  （十种LINQ的常用查询方法）

《C#高级编程（第九版）》 第11章 （详细讲解）

### 11. 委托
当需要把方法传递给其他方法时，就需要用到委托。
####使用方法
1. 定义：
~~~~ C#
delegate void MyDelegate(string arg1,int arg2);
~~~~
2. 创建实例：
~~~~ C#
MyDelegate delegate1 = new MyDelegate(Method1);//此方式创建委托并绑定一个方法

MyDelegate delegate2;//创建委托
delegate2 = Method1;//绑定方法，只要返回类型和参数类型一致，可以自动转换为委托
delegate2 += Method2;//添加绑定方法，一个委托可以绑定多个方法，执行时依次执行。

public static void Method1(string arg1,int arg2)
{
    Console.WriteLine("Method1:"+arg1+"("+arg2+")");
}
public static void Method2(string arg1,int arg2)
{
    //Method2
}
~~~~
3. 使用
可以直接执行委托：
~~~~ C#
delegate1("abc",10);
~~~~
也可以作为参数传递给其他方法（该方法接收类型为该委托的参数）：
~~~~ C#
Method13(delegate2,"abc",10);//执行方法Method2,将委托实例作为参数传递

private void Method3(MyDelegate delegate,string arg1,int arg2)
{
    //...
    delegate(arg1,arg2);
}
~~~~
委托可以同时绑定多个实例。
####使用场景
方法执行的操作并不是针对数据进行，而是要对另一个方法进行操作，而且，在编译阶段无法得知第二个方法时什么，只有在运行时才能
得知，这是需要把第二个方法作为参数传递个第一个方法，这就使用到了委托。如下几个常用委托的场景：
> * 启动线程和任务
> * 通用库类
> * 事件

####参考
http://www.tracefact.net/CSharp-Programming/Delegates-and-Events-in-CSharp.aspx

### 12. 事件
事件基于委托，为委托提供了一种发布/订阅机制。是类在发生其关注的事情时用来提供通知的一种方式。
####使用方法
1. 声明一个委托：
~~~~ C#
public delegate void PublishEventHander();
~~~~
2. 在委托的机制下我们建立以个出版事件：
~~~~ C#
 public event PublishEventHander OnPublish;
~~~~
3. 触发：
事件必须要在方法里去触发：
~~~~ C#
 public void issue()
{
    //如果有人注册了这个事件，也就是这个事件不是空
    if (OnPublish != null)
    {
        Console.WriteLine("触发事件");
        OnPublish();
    }
}
~~~~
4. 订阅：

~~~~ C#
Publisher publisher = new Publisher();

//为事件注册订阅者
publisher.OnPublish += new Publisher.PublishEventHander(Receive);
//另一种事件注册方式
//publisher.OnPublish += Receive;
//发布者在这里触发事件
publisher.issue();
~~~~
订阅者的相关事件
~~~~
public static void Receive()
{
    Console.WriteLine("我是XXX,我已经接到通知");
}
~~~~
####参考
http://www.cnblogs.com/wudiwushen/archive/2010/04/20/1703763.html（通俗易懂）
### 12. 异步编程
使用异步编程，方法调用是在后台运行（通常在线程或任务的协助下），并不会阻塞调用线程。
#### 3种模式
> * 异步模式
> * 基于事件的异步模式
> * 基于任务的异步模式

主要介绍第三种基于任务的异步模式。
一般情况下，该模式定义一个带有“Async” 后缀的方法，并且返回一个Task类型。
方法声明的返回值类型为Task<T> ，但并不需要声明一个Task<T>类型的变量作为返回结果。只需要声明一个T类型的变量，并使用await关键字即可。

如，Abp中AbpRepositoryBase类中的GetAsync方法：
~~~~ C#
public virtual async Task<TEntity> GetAsync(TPrimaryKey id)
{
    var entity = await FirstOrDefaultAsync(id);
    if (entity == null)
    {
        throw new AbpException("There is no such an entity with given primary key. Entity type: " + typeof(TEntity).FullName + ", primary key: " + id);
    }
    return entity;
}
~~~~
#### async 和await
使用 async 修饰符可将方法、lambda 表达式或匿名方法指定为异步。
如果 async 关键字修饰的方法不包含 await 表达式或语句，则该方法将同步执行。

####使用
Abp中AbpRepositoryBase类

####参考
https://msdn.microsoft.com/zh-cn/library/hh191443.aspx
https://msdn.microsoft.com/zh-cn/library/hh156513.aspx
《C#高级编程（第9版）》 第13章 异步编程

### 13. HttpApplication
在HttpApplication中，利用.Net中的事件机制，通过在处理过程中依次发出的多个事件，将这个处理过程分解为多个步骤，这个处理机制通常我们称为处理管道。
HttpApplication处理管道示意图：
![aaa](http://images.cnitblog.com/blog/347600/201401/211102040003.jpg)

http://www.cnblogs.com/kissdodog/p/3527922.html

### 14. VS使用，项目结构


### 15. EF
### 16. NuGet